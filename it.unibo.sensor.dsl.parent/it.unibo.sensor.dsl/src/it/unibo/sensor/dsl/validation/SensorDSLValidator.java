/*
 * generated by Xtext 2.37.0
 */
package it.unibo.sensor.dsl.validation;


import it.unibo.sensor.dsl.sensorDSL.Query;
import it.unibo.sensor.dsl.sensorDSL.SensorDSLPackage;
import org.antlr.runtime.tree.Tree;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class SensorDSLValidator extends AbstractSensorDSLValidator {
	
//	public static final String INVALID_NAME = "invalidName";
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					SensorDSLPackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
    @Check(CheckType.FAST)
    public void ensureThresholdValueIsValid(@NonNull Query query) {
        final String value = query.getValue();
        try {
            final double doubleValue = Double.parseDouble(value);
            final int limit = 10_000;
            if (limit < doubleValue || doubleValue < -limit) {
                error("The value must valid and must be in the interval [%s, %s].".formatted(-limit, limit), query, SensorDSLPackage.Literals.QUERY__VALUE, 0);
            }
        } catch (Exception e) {
            error("The value must be a valid double.", query, SensorDSLPackage.Literals.QUERY__VALUE, 0);
        }
    }
}
